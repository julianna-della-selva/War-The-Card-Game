"""
Julianna Della Selva
December 2025, Python 3.108
WarCards.py

This program runs through the War card game, as traditionally played
Will be altered to accomodate for strategy in a later project

Basic functionality:

Deck of Cards:
Contains:
The generation of the card deck
Shuffling of the deck
Dealing of the deck
- In War, the deck is split in half to create two hands of 26 cards each

Players:
Contains:
Player name
Player hand (their pile of cards)
Rounds:
Contains:
Basic Round functionality
Special Round (War!) functionality

Basic instructions:
Basic Round:
Players 1 and 2 pick up the first card in their hand
they place it down at the same time
compare the values of the two cards (Ace = 14, the highest)
the player whose card has the greater value wins the round
this player takes their card and the losing player's card (in that order) and puts it at the bottom of their hand
repeat

Special Round (War!)
if both players 1 and 2 place a card of the same value at the same time down
War round begins:
put drawn cards back into their respective deck
each player places three cards face down
each player then draws a fourth card and places it face up
the face up cards are compared:
if one player has a card that has a greater value than the other
they take all of the cards (theirs then the losing cards)
begin new round
if they tie
begin another War round
if a player does not have enough cards for War:
End game

End game:
once a player has no cards/a player has the full deck or War round case:
player with the full deck wins
player with the empty deck loses


    Possible helper function for checking hands before war:
    def check_hands(self):
        if (len(self.p1_hand) < 4):
            print("Player 1 does not have enough cards to go to war\n Player 2 wins!")
            return self.p1_hand, self.p2_hand
        elif (len(self.p2_hand) < 4):
            print("Player 2 does not have enough cards to go to war\n Player 1 wins!")
            return self.p1_hand, self.p2_hand

    Possible helper function for spoils handling:

    def spoils_handling(self, spoils, winner):
        for card in spoils:
            winner.append(card)
        return winner


    Current problem:
    When war_round is called recursively, the updated hands are not returned properly
    "Cards" are lost in the process due to the recursion
    Possible solutions:
    1. Use loops instead of recursion
       - keep a war_in_progress boolean variable that continues the war rounds until a player wins
       - the easiest solution
    2. Find a way to properly return updated hands through recursion
       - might be more complex, but would be a good exercise
    3. Other ideas

    Previous war_round function using recursion:
    def war_round(self, p1_hand, p2_hand, spoils = []):
            p1_war = []
            p2_war = []
            for i in range (0,4):
                p1_war.append(p1_hand.pop(0))
                p2_war.append(p2_hand.pop(0))
            p1_war_card = p1_war.pop()
            p2_war_card = p2_war.pop()
            print(f"{self.p1_name}'s war card: {p1_war_card}\n{self.p2_name}'s war card: {p2_war_card}")
            if p1_war_card[0] > p2_war_card[0]:
                print(f"{self.p1_name} wins the round")
                self.p1_hand.extend(spoils + p1_war + [p1_war_card] + p2_war + [p2_war_card])
                return self.p1_hand, self.p2_hand
            elif p1_war_card[0] < p2_war_card[0]:
                print(f"{self.p2_name} wins the round")
                self.p2_hand.extend(spoils + p2_war + [p2_war_card] + p1_war + [p1_war_card])
                return self.p1_hand, self.p2_hand
            else:
                print("Both players' war card have the same value: time for another War!")
                spoils.extend(p1_war + [p1_war_card] + p2_war + [p2_war_card])
                p1_war.clear()
                p2_war.clear()
                p1_war_card = []
                p2_war_card = []
                return self.war_round(p1_hand, p2_hand, spoils)
"""